---
title: "Step by Step Guide to Improving Cohesion in Elixir"
date: 2020-05-25T11:04:29-04:00
draft: true
---

It is the kind of code that makes you squint. It could be that stray business logic in a controller, a view that queries the database, or even two intertwined features that change for different reasons. I am talking about code that is hard to read.

Code that confuses us and our teammates often has one property, it lacks Cohesion. But what is Cohesion? And what does applying it look like?

# What is Cohesion?

Hard to read code often jumbles unrelated concepts together in one place, requiring the reader to juggle multiple ideas. This puts the responsibility on the reader to figure out what is relevant, and what is not. In short it is not Cohesive.

That is the point, Cohesive code is related elements, in the same function or module.
Let me make this more concrete, take a look at the module below. And ask yourself, “Is the `is_admin/1` function related to the `determine_score/3` function?”

You probably answered, “Nope.” And you would be correct.

```
defmodule User do
  def is_admin(user_id)
    #...
  end
  def determine_score(game, user_id, date) do
     # ...
  end
end
```

But why are these two pieces of code unrelated? Because we can think about them separately. Whether a user is an admin, has no bearing on what their score is in a game.

Here are a few other questions that you could ask yourself to determine if code is not related:

1. Do the functions change for different reasons?
1. Do the functions deal with different types of unrelated behavior?
1. Are there lots of nested conditionals?

These questions can provide valuable hints that the code may lack cohesion. However, cohesion is not binary, it is a continuum. What is the ideal amount of cohesion depends on the size and complexity of your code. The larger and more complex the pieces of code becomes, the more you need to separate them. It is easy to see why that is true if we consider two unrelated functions at different scales.

First, imagine two tiny unrelated functions nestled together in the same module. This doesn’t seem like a big deal. Both pieces are small, and we can very quickly determine that they are unrelated, and can think about them separately.

Next, consider two 65+ line unrelated functions—along with their associated helpers functions—in the same module. I don’t know about you but my head is spinning just imagining it. And the people who read our code will probably feel the same way.

When there is lots of unrelated code in the same place, it is not easy to determine what to focus on. We have to constantly search to see where a function is used in order to determine if it is relevant to our task. We probably have to read it several times before we understand it.

As a general rule of thumb, it is a good idea to separate unrelated code as its size and complexity increases. “So how do we move code that is unrelated apart?” Let’s talk about that next.

# Separating Unrelated Code

So, you have identified some code that should be separate! Awesome! But how do you do that? Not to worry, refactoring is here to save the day! More specifically *the Extract Module* refactoring technique.

The Extract Module refactoring moves functions from one module into a newly created module. This allows us to increase the cohesion of our code, and therefore increase its readability.

Below you will find the steps to the Extract Module refactoring. Like all refactorings it is very important we verify the code still works at every step. The best way to check is this is by running the unit tests—though I will omit this implicit phase after each step.

Here are the steps for the Extract Module refactoring:

1. Identify the business concept to extract
1. Rename the existing Module if it conflicts with the name of the business concept
1. Create a Module with the name of the business concept
1. Move data to the newly created Module
1. Replace all uses of the local data with the Module
1. Use the Extract Function Refactoring on business logic
1. Use the Move Function Refactoring to move a function that references data to the new Module
1. Repeat for all functions
1. Repeat for all data

# Applying the Extract Module Refactoring

Sure we have a list of steps, but we need some code to perform them on, so I have provided an example in Elixir. The aspect of this code that you should focus on is that business logic is in something called a GenServer. For the purpose of this article you can think about GenServer as if it is a controller in Rails, or a middleware function in Express. In both situations the business logic and routing logic will change for different reasons. Here is an article where [I show what GenServers are, and how to write them using TDD](https://www.stridenyc.com/blog/what-is-a-genserver-in-elixir).

With our metaphor for a GenServer as a controller, Take a look at the code below. Notice that the code implements logic for a BookStore as a GenServer. The BookStore is able to give clients all its books, add new books, query by book name, and query by id.

```elixir
defmodule BookStore do
  use GenServer

  def start_link() do
    GenServer.start_link(__MODULE__, :ok)
  end

  def all_books(pid) do
    GenServer.call(pid, :all_books)
  end

  def add(pid, book) do
    GenServer.cast(pid, {:add, book})
  end

  def query(pid, term) do
    GenServer.call(pid, {:query, term})
  end

  def find(pid, id) do
    GenServer.call(pid, {:find, id})
  end

  def purchase(pid, id) do
    GenServer.cast(pid, {:purchase, id})
  end

  def init(:ok) do
    {:ok, []}
  end

  def handle_call(:all_books, _from, books) do
    sorted_books =
      books
      |> Enum.sort_by(fn %Book{purchases: purchases} -> purchases end, &>=/2)

    {:reply, sorted_books, books}
  end

  def handle_call({:find, id_to_find}, _from, books) do
    result =
      books
      |> Enum.find(:book_not_found, fn %Book{id: id} -> id == id_to_find end)

    {:reply, result, books}
  end

  def handle_call({:query, term}, _from, books) do
    downcased_query = String.downcase(term)

    matches =
      books
      |> Enum.filter(
           fn %Book{name: name} ->
             name
             |> String.downcase()
             |> String.contains?(downcased_query)
           end
         )
      |> Enum.sort_by(fn %Book{purchases: purchases} -> purchases end, &>=/2)

    {:reply, matches, books}
  end

  def handle_cast({:add, book}, books) do
    book_with_id = %Book{book | id: UUID.uuid1}
    {:noreply, [book_with_id | books]}
  end

  def handle_cast({:purchase, id_to_purchase}, books) do
    updated_books =
      books
      |> Enum.map(fn %Book{id: id, purchases: purchases} = book ->
        case id == id_to_purchase do
          true ->
            %Book{book | purchases: purchases + 1 }
          false -> book
        end
      end)

    {:noreply, updated_books}
  end
end
```

The first step of this refactoring process is to *Identify the business concept to extract*. As mentioned above, the concept we want to extract is a `BookStore`.

In order to start the process of decoupling the business concept we next need to first *Rename the existing Module*. So we change the `BookStore` module name to `BookStoreGenServer`, allowing the names to not conflict.

 ```diff
- defmodule BookStore do
+ defmodule BookStoreGenServer do
  # ...
end
 ```

With our GenServer renamed, we can now *Create a Module with the name of the business concept*. This new module will ultimately hold all of the BookStore logic. Create a new module named `BookStore`.

```
defmodule BookStore do
end
```

Now we have a module to represent the business concept, it is time to *Move data to the newly created Module*. In order to convert the `BookStore` into a data structure add a `defstruct` statement containing the Keyword List with one key, `:books`, mapping to an empty List.

```
defmodule BookStore do
  defstruct [books: []]
end
```

It is time to go through and *Replace all uses of the local data with the Module*. This entails changing the initialization of the state to use the `BookStore` struct, as well as changing any callback functions to destructure out the relevant attributes.

```diff
def init(:ok) do
-   {:ok, []}
+   {:ok, %BookStore{}}
end
```

With the state of the GenServer now a BookStore module, the way the state is used in all `handle_*` functions needs to change. Here is an example of how to make this change for a `handle_call` function.

Notice our use of pattern matching to pull out the relevant data, in the arguments. Make sure to return the entire BookStore in the reply tuple on the last line of the callback.

```diff
-  def handle_call({:find, id_to_find}, _from, books) do
+  def handle_call({:find, id_to_find}, _from, %BookStore{books: books} = book_store) do
    result =
      books
      |> Enum.find(:book_not_found, fn %Book{id: id} -> id == id_to_find end)

+    {:reply, result, books}
+    {:reply, result, book_store}
  end
```

Here is an example of how to change it in `handle_cast/2`. In this type of callback function, we want to pattern match the books out of the BookStore, but we don't need a variable for the store since we will create a new one each time.

```elixir
-  def handle_cast({:purchase, id_to_purchase}, books) do
+  def handle_cast({:purchase, id_to_purchase}, %BookStore{books: books}) do
    updated_books =
      books
      |> Enum.map(fn %Book{id: id, purchases: purchases} = book ->
        case id == id_to_purchase do
          true ->
            %Book{book | purchases: purchases + 1 }
          false -> book
        end
      end)
-    {:noreply, updated_books}
+    {:noreply, %BookStore{books: updated_books}}
  end
```

Continue converting all callback functions to destructure the books attribute out of the `BookStore` struct. When completed, it is time to move business operations onto the `BookStore` module. This process's first step is to *Use the [Extract Function](https://refactoring.com/catalog/extractFunction.html) Refactoring on all business logic*. Once the function is extracted, we can Use *[Move Function](https://refactoring.com/catalog/moveFunction.html) refactoring to move a function that references data to the new Module*. I won't walk you through these steps in order to keep this article short, but they can be found in [Fowler's book](https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature-ebook/dp/B07LCM8RG2/ref=sr_1_1?dchild=1&keywords=refactoring&qid=1589929247&sr=8-1). Though it is necessary to follow the steps that Fowler defines in his book due to the lack of automated refactoring support in Elixir at the moment.

Remember these steps are necessary, because business logic has no place in a GenServer. It is all about making state accessible and fault tolerant to multiple functions running in other processes. We don't want to change our core logic if we change how a GenServer works—or vice versa.

Below I have demonstrated a before and after of the two steps (Extract Function, and Move Function). This process should be repeated for all operations you wish to extract from the GenServer. Here is an example of extracting then moving the `all_books/1` function.

```elixir
defmodule BookStore do
  defstruct [books: []]

+  def all_books(%BookStore{books: books}) do
+    books
+    |> Enum.sort_by(fn %Book{purchases: purchases} -> purchases end, &>=/2)
+  end
end

defmodule BookStoreGenServer do
  # ...
  def handle_call(:all_books, _from, %BookStore{books: books} = book_store) do
-    sorted_books =
-      books
-      |> Enum.sort_by(fn %Book{purchases: purchases} -> purchases end, &>=/2)
-
-    {:reply, sorted_books, book_store}
+    {:reply, BookStore.all_books(book_store), book_store}
  end
  # ...
end
```

Observe below a second example of moving the `find_by_id/2`. After moving this function, it is also possible to rename the `id_to_find` to `id` in the handle_call callback.

```elixir
defmodule BookStore do
  # ...

+  def find_by_id(%BookStore{books: books}, id_to_find) do
+    books
+    |> Enum.find(:book_not_found, fn %Book{id: id} -> id == id_to_find end)
+  end
end

defmodule BookStoreGenServer do
  # ...
+ def handle_call({:find, id}, _from, %BookStore{} = book_store) do
- def handle_call({:find, id_to_find}, _from, %BookStore{books: books} = book_store) do
-    result =
-      books
-      |> Enum.find(:book_not_found, fn %Book{id: id} -> id == id_to_find end)
-
+    {:reply, BookStore.find_by_id(book_store, id), book_store}
-    {:reply, result, book_store}
  end
  # ...
end

```

Continue to follow these steps until all data and functions are moved from the GenServer to the `BookStore` module. Here is what a completed refactoring could look like:

```elixir
defmodule BookStore do
  defstruct [books: []]

  def all_books(%BookStore{books: books}) do
    books
    |> Enum.sort_by(fn %Book{purchases: purchases} -> purchases end, &>=/2)
  end

  def add(%BookStore{books: books}, book) do
    book_with_id = %Book{book | id: UUID.uuid1}
    %BookStore{books: [book_with_id | books]}
  end

  def find_by_id(%BookStore{books: books}, id_to_find) do
    books
    |> Enum.find(:book_not_found, fn %Book{id: id} -> id == id_to_find end)
  end

  def purchase_book(%BookStore{books: books}, id_to_purchase) do
    updated_books =
      books
      |> Enum.map(
           fn %Book{id: id, purchases: purchases} = book ->
             case id == id_to_purchase do
               true ->
                 %Book{book | purchases: purchases + 1}
               false -> book
             end
           end
         )

    %BookStore{books: updated_books}
  end

  def find_by_name(%BookStore{books: books}, term) do
    downcased_query = String.downcase(term)

    books
    |> Enum.filter(
         fn %Book{name: name} ->
           name
           |> String.downcase()
           |> String.contains?(downcased_query)
         end
       )
    |> Enum.sort_by(fn %Book{purchases: purchases} -> purchases end, &>=/2)
  end
end

defmodule BookStoreGenServer do
  use GenServer

  def start_link() do
    GenServer.start_link(__MODULE__, :ok)
  end

  def all_books(pid) do
    GenServer.call(pid, :all_books)
  end

  def add(pid, book) do
    GenServer.cast(pid, {:add, book})
  end

  def query(pid, term) do
    GenServer.call(pid, {:query, term})
  end

  def find(pid, id) do
    GenServer.call(pid, {:find, id})
  end

  def purchase(pid, id) do
    GenServer.cast(pid, {:purchase, id})
  end

  def init(:ok) do
    {:ok, %BookStore{}}
  end

  def handle_call(:all_books, _from, %BookStore{} = book_store) do
    {:reply, BookStore.all_books(book_store), book_store}
  end

  def handle_call({:find, id}, _from, %BookStore{} = book_store) do
    {:reply, BookStore.find_by_id(book_store, id), book_store}
  end

  def handle_call({:query, term}, _from, %BookStore{} = book_store) do
    {:reply, BookStore.find_by_name(book_store, term), book_store}
  end

  def handle_cast({:add, book}, %BookStore{} = book_store) do
    {:noreply, BookStore.add(book_store, book)}
  end

  def handle_cast({:purchase, id}, %BookStore{} = book_store) do
    {:noreply, BookStore.purchase_book(book_store, id)}
  end
end
```

# Improving Your Code

In this article we defined Cohesion as a way to answer the question, "Does this code belong in the same structure as that code?"
Code that is not Cohesive is typically more difficult to read.

With readability as the focus, it is now possible to use Cohesion as a way to identify code that should be extracted.

The steps to the Extract Module Refactoring (based on the Extract Class Refactoring), allow us to make this type of change easy in our system. Here are the steps again, with the assumption that you run all the tests after each stage.

1. Identify the business concept to extract
1. Rename the existing Module if it conflicts with the name of the business concept
1. Create a Module with the name of the business concept
1. Move data to the newly created Module
1. Replace all uses of the local data with the Module
1. Use the Extract Function Refactoring on business logic
1. Use the Move Function Refactoring to move a function that references data to the new Module
1. Repeat for all functions
1. Repeat for all data

We then walked through applying this refactoring method to some Elixir code that coupled business logic for a `BookStore` to a GenServer. With our refactoring complete we are now able to use our business logic in multiple places in the system, rather than rewrite it—or worse copy paste and modify it.


